Sure! Here's a detailed line-by-line explanation of the updated Wi-Fi mode switching and scanning code:

### Import Statements
```python
import subprocess
import tkinter as tk
from tkinter import messagebox
import os
import time
```
- **subprocess**: This module allows you to run system commands (like `ip link` and `airodump-ng`) from within Python.
- **tkinter**: This is the standard Python library for building graphical user interfaces (GUIs).
- **messagebox**: A submodule of `tkinter` used to show message boxes (such as error or info dialogs).
- **os**: This module allows interaction with the operating system, such as file handling, though it is not actively used in this code (could be removed).
- **time**: Provides time-related functions. Here it is used to pause the execution for a few seconds while scanning for networks.

---

### Function to Run System Commands
```python
def run_command(command):
    result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return result.stdout.decode(), result.stderr.decode()
```
- **run_command(command)**: This function runs a shell command (like `ip link` or `airodump-ng`) and returns the output and error messages (if any).
  - `subprocess.run()`: Runs the command in the system shell.
  - `stdout=subprocess.PIPE`: Captures the command's standard output (e.g., the results of the command).
  - `stderr=subprocess.PIPE`: Captures any error messages generated by the command.
  - The function returns two strings: the command's output and any error messages.

---

### Switch to Monitor Mode
```python
def set_monitor_mode(interface):
    output, error = run_command(f"iw dev {interface} info")
    if "mode monitor" in output:
        return f"{interface} is already in monitor mode."
    
    run_command(f"sudo ip link set {interface} down")
    run_command(f"sudo ip link set {interface} name {interface}mon")
    run_command(f"sudo ip link set {interface}mon up")
    return f"{interface} is now in monitor mode."
```
- **set_monitor_mode(interface)**: Switches the given Wi-Fi interface to monitor mode.
  - **Check current mode**: `iw dev {interface} info` is run to get information about the interface. If the output indicates the interface is already in monitor mode, it returns a message saying so.
  - **Switch to monitor mode**:
    - `sudo ip link set {interface} down`: Disables the interface.
    - `sudo ip link set {interface} name {interface}mon`: Renames the interface to `{interface}mon` to indicate it is in monitor mode.
    - `sudo ip link set {interface}mon up`: Enables the interface in monitor mode.
  - The function returns a success message once the interface is switched to monitor mode.

---

### Switch to Managed Mode
```python
def set_managed_mode(interface):
    output, error = run_command(f"iw dev {interface} info")
    if "mode managed" in output:
        return f"{interface} is already in managed mode."
    
    run_command(f"sudo ip link set {interface}mon down")
    run_command(f"sudo ip link set {interface} name {interface}")
    run_command(f"sudo ip link set {interface} up")
    return f"{interface} is now in managed mode."
```
- **set_managed_mode(interface)**: Switches the Wi-Fi interface back to managed mode.
  - **Check current mode**: Similar to the monitor mode function, it checks if the interface is already in managed mode. If so, it returns a message saying so.
  - **Switch to managed mode**:
    - `sudo ip link set {interface}mon down`: Disables the monitor mode interface.
    - `sudo ip link set {interface} name {interface}`: Renames the interface back to its original name.
    - `sudo ip link set {interface} up`: Enables the interface in managed mode.
  - The function returns a success message once the interface is switched to managed mode.

---

### Scan Networks and Parse Results
```python
def scan_networks(interface):
    output, error = run_command(f"sudo airodump-ng --output-format csv --write temp_scan {interface}mon")
    
    if error:
        print(f"Error scanning networks: {error}")
        return []
    
    time.sleep(5)
    
    networks = []
    with open("temp_scan-01.csv", "r") as file:
        lines = file.readlines()
        for line in lines:
            if line.startswith("Station MAC"):
                continue  # Skip header lines
            fields = line.split(",")
            if len(fields) > 0:
                networks.append(fields[0])  # The first field is the BSSID
    return networks
```
- **scan_networks(interface)**: Uses `airodump-ng` to scan for available Wi-Fi networks and returns a list of BSSIDs (MAC addresses of the networks).
  - **Run `airodump-ng`**: The `airodump-ng` tool is run with the specified interface in monitor mode (`{interface}mon`). The output is saved to a CSV file (`temp_scan-01.csv`).
  - **Error handling**: If there's an error in running `airodump-ng`, an error message is printed, and the function returns an empty list.
  - **Sleep**: The script waits for 5 seconds to ensure `airodump-ng` has enough time to capture network data.
  - **Parse CSV**: The script reads the `temp_scan-01.csv` file, skips the header line (`Station MAC`), and extracts the first column (BSSID, the MAC address of the network). The BSSIDs are stored in a list (`networks`).
  - **Return**: A list of BSSIDs is returned.

---

### Handle Scan Button Click
```python
def handle_scan_button(interface):
    bssids = scan_networks(interface)
    if bssids:
        listbox.delete(0, tk.END)  # Clear current listbox
        for bssid in bssids:
            listbox.insert(tk.END, bssid)
    else:
        messagebox.showerror("Scan Error", "Failed to scan networks or no networks found.")
```
- **handle_scan_button(interface)**: This function is triggered when the "Scan for Networks" button is clicked in the GUI.
  - **Call `scan_networks`**: It calls the `scan_networks` function to get the list of BSSIDs.
  - **Update Listbox**: If networks are found, it clears the current list in the listbox (`listbox.delete(0, tk.END)`) and inserts each BSSID into the listbox.
  - **Error Handling**: If no networks are found, an error message is shown in a message box.

---

### Handle Mode Switch
```python
def handle_mode_switch(interface, mode):
    try:
        if mode == "Monitor":
            status = set_monitor_mode(interface)
            mode_label.config(text=f"Mode: Monitor ({interface}mon)")
        else:
            status = set_managed_mode(interface)
            mode_label.config(text=f"Mode: Managed ({interface})")
        messagebox.showinfo("Mode Switch", status)
    except Exception as e:
        messagebox.showerror("Mode Switch Error", f"Error switching modes: {str(e)}")
```
- **handle_mode_switch(interface, mode)**: This function switches the Wi-Fi interface mode based on the user selection (either "Monitor" or "Managed").
  - **Switch mode**: It calls either `set_monitor_mode` or `set_managed_mode` based on the `mode` argument.
  - **Update GUI label**: It updates the label (`mode_label`) in the GUI to reflect the current mode.
  - **Error Handling**: If there's an error during the mode switch, a message box is shown with the error message.

---

### GUI Setup
```python
root = tk.Tk()
root.title("Wi-Fi Network Scanner and Mode Switcher")
```
- **GUI Initialization**: The root window (`root`) for the GUI is created, and its title is set to "Wi-Fi Network Scanner and Mode Switcher".

---

### Interface, Mode, and Buttons
```python
interface_label = tk.Label(root, text="Enter Wi-Fi Interface (e.g., wlan0):")
interface_label.pack(pady=5)

interface_entry = tk.Entry(root)
interface_entry.pack(pady=5)

mode_label = tk.Label(root, text="Mode: Managed")
mode_label.pack(pady=5)

scan_button = tk.Button(root, text="Scan for Networks", command=lambda: handle_scan_button(interface_entry.get()))
scan_button.pack(pady=5)

mode_switch_button = tk.Button(root, text="Switch to Monitor Mode", 
                               command=lambda: handle_mode_switch(interface_entry.get(), "Monitor"))
mode_switch_button.pack(pady=5)

switch_to_managed_button = tk.Button(root, text="Switch to Managed Mode", 
                                     command=lambda: handle_mode_switch(interface_entry.get(), "Managed"))
switch_to_managed_button.pack(pady=5)

listbox = tk.Listbox(root, width=40, height=10)
listbox.pack(pady=5)
```
- **Labels and Buttons**: Various elements (labels, buttons, and entry fields) are added to the GUI.
  - **`interface_label`**: A label asking the user to enter the Wi-Fi interface name.
  - **`interface_entry`**: An entry field where the user can input the interface name (e.g., `wlan0`).
  - **`mode_label`**: A label showing the current mode of the interface (either "Monitor" or "Managed").
  - **`scan_button`**: A button that starts the network scan when clicked. It calls `handle_scan_button` with the interface entered in the `interface_entry`.
  - **`mode_switch_button`**: A button that switches the interface to monitor mode when clicked. It calls `handle_mode_switch` with the argument `"Monitor"`.
  - **`switch_to_managed_button`**: A button that switches the interface back to managed mode when clicked. It calls `handle_mode_switch` with the argument `"Managed"`.
  - **`listbox`**: A listbox widget that displays the BSSIDs of available networks.

---

### Main GUI Loop
```python
root.mainloop()
```
- **Start the GUI**: This line starts the main loop of the GUI, allowing it to interact with the user and handle events such as button clicks and interface changes.

---

This explanation covers each part of the code and its functionality. The main goal is to create a GUI where you can:
1. Switch the Wi-Fi interface between monitor and managed modes.
2. Scan for available networks and display their BSSIDs.
